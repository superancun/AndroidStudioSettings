<application>
  <component name="AppStorage">
    <histories>
      <item value="Denotes that any overriding methods should invoke this method as well." />
      <item value="recharge" />
      <item value="To remove routes until a route with a certain name, use the [RoutePredicate] returned from [ModalRoute.withName]. To remove all the routes below the pushed route, use a [RoutePredicate] that always returns false (e.g. `(Route&lt;dynamic&gt; route) =&gt; false`)." />
      <item value="Push the route with the given name onto the navigator that most tightly encloses the given context, and then remove all the previous routes until the `predicate` returns true." />
      <item value="A piece of material." />
      <item value="the extentAfter distance of trigger loading" />
      <item value="The boundary is located at the bottom edge and stops when inertia rolls under the boundary distance" />
      <item value="A constant that is true if the application was compiled to run on the web. This implementation takes advantage of the fact that JavaScript does not support integers. In this environment, Dart's doubles and ints are backed by the same kind of object. Thus a double `0.0` is identical to an integer `0`. This is not true for Dart code running in AOT or on the VM." />
      <item value="Pop the current route off the navigator that most tightly encloses the given context and push a named route in its place." />
      <item value="Switches themes for this {@code Activity} from the theme used to launch this {@code Activity} to a &quot;normal theme&quot; that is intended for regular {@code Activity} operation. &lt;p&gt;This behavior is offered so that a &quot;launch screen&quot; can be displayed while the application initially loads. To utilize this behavior in an app, do the following: &lt;ol&gt; &lt;li&gt;Create 2 different themes in style.xml: one theme for the launch screen and one theme for normal display. &lt;li&gt;In the launch screen theme, set the &quot;windowBackground&quot; property to a {@code Drawable} of your choice. &lt;li&gt;In the normal theme, customize however you'd like. &lt;li&gt;In the AndroidManifest.xml, set the theme of your {@code FlutterActivity} to your launch theme. &lt;li&gt;Add a {@code &lt;meta-data&gt;} property to your {@code FlutterActivity} with a name of &quot;io.flutter.embedding.android.NormalTheme&quot; and set the resource to your normal theme, e.g., {@code android:resource=&quot;@styleMyNormalTheme}. &lt;ol&gt; With the above settings, your launch theme will be used when loading the app, and then the theme will be switched to your normal theme once the app has initialized. &lt;p&gt;Do not change aspects of system chrome between a launch theme and normal theme. Either define both themes to be fullscreen or not, and define both themes to display the same status bar and navigation bar settings. If you wish to adjust system chrome once your Flutter app renders, use platform channels to instruct Android to do so at the appropriate time. This will avoid any jarring visual changes during app startup." />
      <item value="Sets this {@code Activity}'s {@code Window} background to be transparent, and hides the status bar, if this {@code Activity}'s desired {@link BackgroundMode} is {@link BackgroundModetransparent}. &lt;p&gt;For {@code Activity} transparency to work as expected, the theme applied to this {@code Activity} must include {@code &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;item&gt;}." />
      <item value="Theme applied to the Android Window as soon as the process has started. This theme determines the color of the Android Window while your Flutter UI initializes, as well as behind your Flutter UI while its running." />
      <item value="{@macro flutter.widgets.widgetsApp.shortcuts} {@tool snippet} This example shows how to add a single shortcut for [LogicalKeyboardKey.select] to the default shortcuts without needing to add your own [Shortcuts] widget. Alternatively, you could insert a [Shortcuts] widget with just the mapping you want to add between the [WidgetsApp] and its child and get the same effect." />
      <item value="Why are we surrounding a builder with a builder? The widget.builder may contain code that invokes Theme.of(), which should return the theme we selected above in AnimatedTheme. However, if we invoke widget.builder() directly as the child of AnimatedTheme then there is no Context separating them, and the widget.builder() will not find the theme. Therefore, we surround widget.builder with yet another builder so that a context separates them and Theme.of() correctly resolves to the theme we passed to AnimatedTheme." />
      <item value="{@macro flutter.widgets.widgetsApp.builder} Material specific features such as [showDialog] and [showMenu], and widgets such as [Tooltip], [PopupMenuButton], also require a [Navigator] to properly function." />
      <item value="Manually wait for window size to be initialized `Recommended` to use before you need access window size or in custom splashbootstrap screen [FutureBuilder] example: ```dart ... ScreenUtil.init(context, ...); ... FutureBuilder( future: Future.wait([..., ensureScreenSize(), ...]), builder: (context, snapshot) { if (snapshot.hasData) return const HomeScreen(); return Material( child: LayoutBuilder( ... ), ); }, ) ```" />
      <item value="The number of device pixels for each logical pixel. This number might not be a power of two. Indeed, it might not even be an integer. For example, the Nexus 6 has a device pixel ratio of 3.5." />
      <item value="The size of the media in logical pixels (e.g, the size of the screen)." />
      <item value="If a [Navigator] is created, at least one of these options must handle the `` route, since it is used when an invalid [initialRoute] is specified on startup (e.g. by another application launching this one with an intent on Android; see [dart:ui.PlatformDispatcher.defaultRouteName])." />
      <item value="All restorable properties must be registered with the mixin. After registration, the counter either has its old value restored or is initialized to its default value." />
      <item value="In this example, the restoration ID for the mixin is passed in through the [StatefulWidget]'s constructor." />
      <item value="A property that has been registered outside of [restoreState] must be re-registered within [restoreState] the next time that method is called unless it has been unregistered with [unregisterFromRestoration]." />
      <item value="The current value of the counter is stored in a [RestorableProperty]. During state restoration it is automatically restored to its old value. If no restoration data is available to restore the counter from, it is initialized to the specified default value of zero." />
      <item value="The [State] object uses the [RestorationMixin] to make the current value of the counter restorable." />
      <item value="Denotes that the request body will use form URL encoding. Fields should be declared as parameters and annotated with {@link Field @Field}. &lt;p&gt; Requests made with this annotation will have {@code applicationx-www-form-urlencoded} MIME type. Field names and values will be UTF-8 encoded before being URI-encoded in accordance to &lt;a href=&quot;http:tools.ietf.orghtmlrfc3986&quot;&gt;RFC-3986&lt;a&gt;." />
      <item value="Encodes the string [component] according to the HTML 4.01 rules for encoding the posting of a HTML form as a query string component. Encode the string [component] according to the HTML 4.01 rules for encoding the posting of a HTML form as a query string component. The component is first encoded to bytes using [encoding]. The default is to use [utf8] encoding, which preserves all the characters that don't need encoding. Then the resulting bytes are &quot;percent-encoded&quot;. This transforms spaces (U+0020) to a plus sign ('+') and all bytes that are not the ASCII decimal digits, letters or one of '-._~' are written as a percent sign '%' followed by the two-digit hexadecimal representation of the byte. Note that the set of characters which are percent-encoded is a superset of what HTML 4.01 requires, since it refers to RFC 1738 for reserved characters. When manually encoding query components remember to encode each part separately before building the query string." />
      <item value="{@template riverpod.stateprovider.notifier} Obtains the [StateController] associated with this provider, but without listening to it. Listening to this provider may cause providerswidgets to rebuild in the event that the [StateController] it recreated. It is preferable to do: ```dart ref.watch(stateProvider.notifier) ``` instead of: ```dart ref.read(stateProvider) ``` The reasoning is, using `read` could cause hard to catch bugs, such as not rebuilding dependent providerswidgets after using `ref.refresh` on this provider. {@endtemplate}" />
      <item value="anti-pattern" />
      <item value="CONSIDER" />
      <item value="This has the same efficiency as the previous anti-pattern, but does not suffer from the drawback of being brittle." />
      <item value="Reads a provider without listening to it. AVOID calling [read] inside build if the value is used only for events: ```dart Widget build(BuildContext context) { counter is used only for the onPressed of RaisedButton final counter = ref.read(counterProvider); return RaisedButton( onPressed: () =&gt; counter.increment(), ); } ``` While this code is not bugged in itself, this is an anti-pattern. It could easily lead to bugs in the future after refactoring the widget to use `counter` for other things, but forget to change [read] into [Consumer]`ref.watch(`. CONSIDER calling [read] inside event handlers: ```dart Widget build(BuildContext context) { return RaisedButton( onPressed: () { as performant as the previous solution, but resilient to refactoring ref.read(counterProvider).increment(), }, ); } ```" />
      <item value="as performant as the previous solution, but resilient to refactoring" />
      <item value="Returns a modifiable list of interceptors that observe the full span of each call: from before the connection is established (if any) until after the response source is selected (either the origin server, cache, or both)." />
      <item value="Returns a modifiable list of interceptors that observe a single network request and response. These interceptors must call {@link Interceptor.Chainproceed} exactly once: it is an error for a network interceptor to short-circuit or repeat a network request." />
      <item value="Converts [value] to a JSON string. If value contains objects that are not directly encodable to a JSON string (a value that is not a number, boolean, string, null, list or a map with string keys), the [toEncodable] function is used to convert it to an object that must be directly encodable. If [toEncodable] is omitted, it defaults to a function that returns the result of calling `.toJson()` on the unencodable object." />
      <item value="Combines the string representation of elements into a single string. Each element is converted to a string using its [Object.toString] method. If [separator] is provided, it is inserted between element string representations. The returned future is completed with the combined string when this stream is done. If this stream emits an error, or the call to [Object.toString] throws, the returned future is completed with that error, and processing stops." />
      <item value="Describes the part of the user interface represented by this widget. The framework calls this method when this widget is inserted into the tree in a given [BuildContext] and when the dependencies of this widget change (e.g., an [InheritedWidget] referenced by this widget changes). This method can potentially be called in every frame and should not have any side effects beyond building a widget. The framework replaces the subtree below this widget with the widget returned by this method, either by updating the existing subtree or by removing the subtree and inflating a new subtree, depending on whether the widget returned by this method can update the root of the existing subtree, as determined by calling [Widget.canUpdate]. Typically implementations return a newly created constellation of widgets that are configured with information from this widget's constructor and from the given [BuildContext]. The given [BuildContext] contains information about the location in the tree at which this widget is being built. For example, the context provides the set of inherited widgets for this location in the tree. A given widget might be built with multiple different [BuildContext] arguments over time if the widget is moved around the tree or if the widget is inserted into the tree in multiple places at once. The implementation of this method must only depend on: the fields of the widget, which themselves must not change over time, and any ambient state obtained from the `context` using [BuildContext.dependOnInheritedWidgetOfExactType]." />
      <item value="The framework replaces the subtree below this widget with the widget returned by this method, either by updating the existing subtree or by removing the subtree and inflating a new subtree, depending on whether the widget returned by this method can update the root of the existing subtree, as determined by calling [Widget.canUpdate]." />
      <item value="Creates a scrollable, linear array of widgets that are created on demand. This constructor is appropriate for list views with a large (or infinite) number of children because the builder is called only for those children that are actually visible. Providing a non-null `itemCount` improves the ability of the [ListView] to estimate the maximum scroll extent. The `itemBuilder` callback will be called only with indices greater than or equal to zero and less than `itemCount`. The `itemBuilder` should always return a non-null widget, and actually create the widget instances when called. Avoid using a builder that returns a previously-constructed widget; if the list view's children are created in advance, or all at once when the [ListView] itself is created, it is more efficient to use the [ListView] constructor. Even more efficient, however, is to create the instances on demand using this constructor's `itemBuilder` callback. The `addAutomaticKeepAlives` argument corresponds to the [SliverChildBuilderDelegate.addAutomaticKeepAlives] property. The `addRepaintBoundaries` argument corresponds to the [SliverChildBuilderDelegate.addRepaintBoundaries] property. The `addSemanticIndexes` argument corresponds to the [SliverChildBuilderDelegate.addSemanticIndexes] property. None may be null." />
      <item value="A widget that aligns its child within itself and optionally sizes itself based on the child's size. For example, to align a box at the bottom right, you would pass this box a tight constraint that is bigger than the child's natural size, with an alignment of [Alignment.bottomRight]. {@youtube 560 315 https:www.youtube.comwatch?v=g2E7yl3MwMk} This widget will be as big as possible if its dimensions are constrained and [widthFactor] and [heightFactor] are null. If a dimension is unconstrained and the corresponding size factor is null then the widget will match its child's size in that dimension. If a size factor is non-null then the corresponding dimension of this widget will be the product of the child's dimension and the size factor. For example if widthFactor is 2.0 then the width of this widget will always be twice its child's width. How it works The [alignment] property describes a point in the `child`'s coordinate system and a different point in the coordinate system of this widget. The [Align] widget positions the `child` such that both points are lined up on top of each other." />
      <item value="A widget that clips its child using a rectangle. By default, [ClipRect] prevents its child from painting outside its bounds, but the size and location of the clip rect can be customized using a custom [clipper]. [ClipRect] is commonly used with these widgets, which commonly paint outside their bounds:" />
      <item value="If non-null, sets its width to the child's width multiplied by this factor. Can be both greater and less than 1.0 but must be non-negative." />
      <item value="This is the same as `contain` if that would shrink the image, otherwise it is the same as `none`." />
      <item value="If non-null, require the image to have this width. If null, the image will pick a size that best preserves its intrinsic aspect ratio. It is strongly recommended that either both the [width] and the [height] be specified, or that the widget be placed in a context that sets tight layout constraints, so that the image does not change size as it loads. Consider using [fit] to adapt the image's rendering to fit the given width and height if the exact image dimensions are not known in advance." />
      <item value="Called whenever the widget configuration changes. If the parent widget rebuilds and request that this location in the tree update to display a new widget with the same [runtimeType] and [Widget.key], the framework will update the [widget] property of this [State] object to refer to the new widget and then call this method with the previous widget as an argument. Override this method to respond when the [widget] changes (e.g., to start implicit animations). The framework always calls [build] after calling [didUpdateWidget], which means any calls to [setState] in [didUpdateWidget] are redundant. {@macro flutter.widgets.State.initState} Implementations of this method should start with a call to the inherited method, as in `super.didUpdateWidget(oldWidget)`." />
      <item value="Called to obtain the child widget. This function is called whenever this widget is included in its parent's build and the old widget (if any) that it synchronizes with has a distinct object identity. Typically the parent's build method will construct a new tree of widgets and so a new Builder child will not be [identical] to the corresponding old one." />
      <item value="A widget that lays the child out as if it was in the tree, but without painting anything, without making the child available for hit testing, and without taking any room in the parent." />
      <item value="Register callbacks to be called when this future completes. When this future completes with a value, the [onValue] callback will be called with that value. If this future is already completed, the callback will not be called immediately, but will be scheduled in a later microtask. If [onError] is provided, and this future completes with an error, the `onError` callback is called with that error and its stack trace. The `onError` callback must accept either one argument or two arguments where the latter is a [StackTrace]. If `onError` accepts two arguments, it is called with both the error and the stack trace, otherwise it is called with just the error object. The `onError` callback must return a value or future that can be used to complete the returned future, so it must be something assignable to `FutureOr&lt;R&gt;`. Returns a new [Future] which is completed with the result of the call to `onValue` (if this future completes with a value) or to `onError` (if this future completes with an error). If the invoked callback throws, the returned future is completed with the thrown error and a stack trace for the error. In the case of `onError`, if the exception thrown is `identical` to the error argument to `onError`, the throw is considered a rethrow, and the original stack trace is used instead. If the callback returns a [Future], the future returned by `then` will be completed with the same result as the future returned by the callback. If [onError] is not given, and this future completes with an error, the error is forwarded directly to the returned future. In most cases, it is more readable to use [catchError] separately, possibly with a `test` parameter, instead of handling both value and error in a single [then] call. Note that futures don't delay reporting of errors until listeners are added. If the first `then` or `catchError` call happens after this future has completed with an error, then the error is reported as unhandled error. See the description on [Future]." />
      <item value="tight" />
      <item value="Column has various properties to control how it sizes itself and how it positions its children. Here we use mainAxisAlignment to center the children vertically; the main axis here is the vertical axis because Columns are vertical (the cross axis would be horizontal)." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="9" />
        <entry key="ENGLISH" value="10" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1653879608665" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
  </component>
</application>