<application>
  <component name="AppStorage">
    <histories>
      <item value="Determines the interfaces implemented by the class or interface represented by this object." />
      <item value="the value to return from the method invocation on the proxy instance. If the declared return type of the interface method is a primitive type, then the value returned by this method must be an instance of the corresponding primitive wrapper class; otherwise, it must be a type assignable to the declared return type. If the value returned by this method is {@code null} and the interface method's return type is primitive, then a {@code NullPointerException} will be thrown by the method invocation on the proxy instance. If the value returned by this method is otherwise not compatible with the interface method's declared return type as described above, a {@code ClassCastException} will be thrown by the method invocation on the proxy instance." />
      <item value="Whether the `newWidget` can be used to update an [Element] that currently has the `oldWidget` as its configuration." />
      <item value="Override this method to respond when the [widget] changes (e.g., to start implicit animations)." />
      <item value="Implementations of this method should start with a call to the inherited method, as in `super.didUpdateWidget(oldWidget)`." />
      <item value="The framework always calls [build] after calling [didUpdateWidget], which means any calls to [setState] in [didUpdateWidget] are redundant." />
      <item value="If the parent widget rebuilds and request that this location in the tree update to display a new widget with the same [runtimeType] and [Widget.key], the framework will update the [widget] property of this [State] object to refer to the new widget and then call this method with the previous widget as an argument." />
      <item value="The [future] must have been obtained earlier, e.g. during [State.initState], [State.didUpdateWidget], or [State.didChangeDependencies]. It must not be created during the [State.build] or [StatelessWidget.build] method call when constructing the [FutureBuilder]. If the [future] is created at the same time as the [FutureBuilder], then every time the [FutureBuilder]'s parent is rebuilt, the asynchronous task will be restarted." />
      <item value="interaction" />
      <item value="Whether the `newWidget` can be used to update an [Element] that currently has the `oldWidget` as its configuration. An element that uses a given widget as its configuration can be updated to use another widget as its configuration if, and only if, the two widgets have [runtimeType] and [key] properties that are [operator==]. If the widgets have no key (their key is null), then they are considered a match if they have the same type, even if their children are completely different." />
      <item value="Closing a &lt;tt&gt;ByteArrayOutputStream&lt;tt&gt; has no effect. The methods in this class can be called after the stream has been closed without generating an &lt;tt&gt;IOException&lt;tt&gt;." />
      <item value="Returns an input stream that reads from this open connection. A SocketTimeoutException can be thrown when reading from the returned input stream if the read timeout expires before data is available for read. @return an input stream that reads from this open connection. @exception IOException if an IO error occurs while creating the input stream. @exception UnknownServiceException if the protocol does not support input. @see setReadTimeout(int) @see getReadTimeout()" />
      <item value="Closes this output stream and releases any system resources associated with this stream. The general contract of &lt;code&gt;close&lt;code&gt; is that it closes the output stream. A closed stream cannot perform output operations and cannot be reopened. &lt;p&gt; The &lt;code&gt;close&lt;code&gt; method of &lt;code&gt;OutputStream&lt;code&gt; does nothing. @exception IOException if an IO error occurs." />
      <item value="Flushes this output stream and forces any buffered output bytes to be written out. The general contract of &lt;code&gt;flush&lt;code&gt; is that calling it is an indication that, if any bytes previously written have been buffered by the implementation of the output stream, such bytes should immediately be written to their intended destination. &lt;p&gt; If the intended destination of this stream is an abstraction provided by the underlying operating system, for example a file, then flushing the stream guarantees only that bytes previously written to the stream are passed to the operating system for writing; it does not guarantee that they are actually written to a physical device such as a disk drive. &lt;p&gt; The &lt;code&gt;flush&lt;code&gt; method of &lt;code&gt;OutputStream&lt;code&gt; does nothing. @exception IOException if an IO error occurs." />
      <item value="Response" />
      <item value="Create a proxy for the wrapped object allowing to typesafely invoke methods on it using a custom interface. @param proxyType The interface type that is implemented by the proxy. @return a proxy for the wrapped object" />
      <item value="路由 fluro: ^1.7.8 请求缓存 dio_http_cache: ^0.2.7 图片缓存 cached_network_image: ^2.1.0+1 轮播图 - 插件暂未升级2.0 flutter_swiper: ^1.1.6 加载html标签 flutter_html: ^0.11.1 消息提示框 flutter_svprogresshud: ^0.0.6 fluttertoast: ^7.1.5 响应式编程 rxdart: ^0.23.0 消息中心（事件发送和监听） event_bus: ^1.1.1 调用底层的拨打电话、发送邮件、发送信息以及打开网址和打开第三方应用等等 url_launcher: ^5.4.11 图片选择 image_picker: ^0.6.7+4 音频播放 audioplayers: ^0.15.1 日期选择 flutter_rounded_date_picker: ^1.0.5 格式化时间 date_format: ^1.0.8 获取手机上的文件，清除缓存使用的 path_provider: ^1.6.11 前往app设置 app_settings: ^4.0.2 地区选择 - 插件暂未升级2.0 city_pickers: ^0.1.30 工具类库 flustars: ^0.3.2 权限申请 permission_handler: ^4.2.0 安卓安卓插件 - 插件暂未升级2.0 install_plugin: ^2.0.1 侧滑组件 flutter_slidable: ^0.5.7 画图表 fl_chart: ^0.12.1 charts_flutter: ^0.10.0 syncfusion_flutter_charts: ^18.4.47 扫描二维码 flutter_qr_reader: ^1.0.3 图片压缩 flutter_native_image: ^0.0.5 图片视图，放大缩小等 photo_view: ^0.10.3 保存图片到相册 image_gallery_saver: ^1.6.8 二维码生成 qr_flutter: ^3.1.0" />
      <item value="Denotes that any overriding methods should invoke this method as well." />
      <item value="recharge" />
      <item value="To remove routes until a route with a certain name, use the [RoutePredicate] returned from [ModalRoute.withName]. To remove all the routes below the pushed route, use a [RoutePredicate] that always returns false (e.g. `(Route&lt;dynamic&gt; route) =&gt; false`)." />
      <item value="Push the route with the given name onto the navigator that most tightly encloses the given context, and then remove all the previous routes until the `predicate` returns true." />
      <item value="A piece of material." />
      <item value="the extentAfter distance of trigger loading" />
      <item value="The boundary is located at the bottom edge and stops when inertia rolls under the boundary distance" />
      <item value="A constant that is true if the application was compiled to run on the web. This implementation takes advantage of the fact that JavaScript does not support integers. In this environment, Dart's doubles and ints are backed by the same kind of object. Thus a double `0.0` is identical to an integer `0`. This is not true for Dart code running in AOT or on the VM." />
      <item value="Pop the current route off the navigator that most tightly encloses the given context and push a named route in its place." />
      <item value="Switches themes for this {@code Activity} from the theme used to launch this {@code Activity} to a &quot;normal theme&quot; that is intended for regular {@code Activity} operation. &lt;p&gt;This behavior is offered so that a &quot;launch screen&quot; can be displayed while the application initially loads. To utilize this behavior in an app, do the following: &lt;ol&gt; &lt;li&gt;Create 2 different themes in style.xml: one theme for the launch screen and one theme for normal display. &lt;li&gt;In the launch screen theme, set the &quot;windowBackground&quot; property to a {@code Drawable} of your choice. &lt;li&gt;In the normal theme, customize however you'd like. &lt;li&gt;In the AndroidManifest.xml, set the theme of your {@code FlutterActivity} to your launch theme. &lt;li&gt;Add a {@code &lt;meta-data&gt;} property to your {@code FlutterActivity} with a name of &quot;io.flutter.embedding.android.NormalTheme&quot; and set the resource to your normal theme, e.g., {@code android:resource=&quot;@styleMyNormalTheme}. &lt;ol&gt; With the above settings, your launch theme will be used when loading the app, and then the theme will be switched to your normal theme once the app has initialized. &lt;p&gt;Do not change aspects of system chrome between a launch theme and normal theme. Either define both themes to be fullscreen or not, and define both themes to display the same status bar and navigation bar settings. If you wish to adjust system chrome once your Flutter app renders, use platform channels to instruct Android to do so at the appropriate time. This will avoid any jarring visual changes during app startup." />
      <item value="Sets this {@code Activity}'s {@code Window} background to be transparent, and hides the status bar, if this {@code Activity}'s desired {@link BackgroundMode} is {@link BackgroundModetransparent}. &lt;p&gt;For {@code Activity} transparency to work as expected, the theme applied to this {@code Activity} must include {@code &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;item&gt;}." />
      <item value="Theme applied to the Android Window as soon as the process has started. This theme determines the color of the Android Window while your Flutter UI initializes, as well as behind your Flutter UI while its running." />
      <item value="{@macro flutter.widgets.widgetsApp.shortcuts} {@tool snippet} This example shows how to add a single shortcut for [LogicalKeyboardKey.select] to the default shortcuts without needing to add your own [Shortcuts] widget. Alternatively, you could insert a [Shortcuts] widget with just the mapping you want to add between the [WidgetsApp] and its child and get the same effect." />
      <item value="Why are we surrounding a builder with a builder? The widget.builder may contain code that invokes Theme.of(), which should return the theme we selected above in AnimatedTheme. However, if we invoke widget.builder() directly as the child of AnimatedTheme then there is no Context separating them, and the widget.builder() will not find the theme. Therefore, we surround widget.builder with yet another builder so that a context separates them and Theme.of() correctly resolves to the theme we passed to AnimatedTheme." />
      <item value="{@macro flutter.widgets.widgetsApp.builder} Material specific features such as [showDialog] and [showMenu], and widgets such as [Tooltip], [PopupMenuButton], also require a [Navigator] to properly function." />
      <item value="Manually wait for window size to be initialized `Recommended` to use before you need access window size or in custom splashbootstrap screen [FutureBuilder] example: ```dart ... ScreenUtil.init(context, ...); ... FutureBuilder( future: Future.wait([..., ensureScreenSize(), ...]), builder: (context, snapshot) { if (snapshot.hasData) return const HomeScreen(); return Material( child: LayoutBuilder( ... ), ); }, ) ```" />
      <item value="The number of device pixels for each logical pixel. This number might not be a power of two. Indeed, it might not even be an integer. For example, the Nexus 6 has a device pixel ratio of 3.5." />
      <item value="The size of the media in logical pixels (e.g, the size of the screen)." />
      <item value="If a [Navigator] is created, at least one of these options must handle the `` route, since it is used when an invalid [initialRoute] is specified on startup (e.g. by another application launching this one with an intent on Android; see [dart:ui.PlatformDispatcher.defaultRouteName])." />
      <item value="All restorable properties must be registered with the mixin. After registration, the counter either has its old value restored or is initialized to its default value." />
      <item value="In this example, the restoration ID for the mixin is passed in through the [StatefulWidget]'s constructor." />
      <item value="A property that has been registered outside of [restoreState] must be re-registered within [restoreState] the next time that method is called unless it has been unregistered with [unregisterFromRestoration]." />
      <item value="The current value of the counter is stored in a [RestorableProperty]. During state restoration it is automatically restored to its old value. If no restoration data is available to restore the counter from, it is initialized to the specified default value of zero." />
      <item value="The [State] object uses the [RestorationMixin] to make the current value of the counter restorable." />
      <item value="Denotes that the request body will use form URL encoding. Fields should be declared as parameters and annotated with {@link Field @Field}. &lt;p&gt; Requests made with this annotation will have {@code applicationx-www-form-urlencoded} MIME type. Field names and values will be UTF-8 encoded before being URI-encoded in accordance to &lt;a href=&quot;http:tools.ietf.orghtmlrfc3986&quot;&gt;RFC-3986&lt;a&gt;." />
      <item value="Encodes the string [component] according to the HTML 4.01 rules for encoding the posting of a HTML form as a query string component. Encode the string [component] according to the HTML 4.01 rules for encoding the posting of a HTML form as a query string component. The component is first encoded to bytes using [encoding]. The default is to use [utf8] encoding, which preserves all the characters that don't need encoding. Then the resulting bytes are &quot;percent-encoded&quot;. This transforms spaces (U+0020) to a plus sign ('+') and all bytes that are not the ASCII decimal digits, letters or one of '-._~' are written as a percent sign '%' followed by the two-digit hexadecimal representation of the byte. Note that the set of characters which are percent-encoded is a superset of what HTML 4.01 requires, since it refers to RFC 1738 for reserved characters. When manually encoding query components remember to encode each part separately before building the query string." />
      <item value="{@template riverpod.stateprovider.notifier} Obtains the [StateController] associated with this provider, but without listening to it. Listening to this provider may cause providerswidgets to rebuild in the event that the [StateController] it recreated. It is preferable to do: ```dart ref.watch(stateProvider.notifier) ``` instead of: ```dart ref.read(stateProvider) ``` The reasoning is, using `read` could cause hard to catch bugs, such as not rebuilding dependent providerswidgets after using `ref.refresh` on this provider. {@endtemplate}" />
      <item value="anti-pattern" />
      <item value="CONSIDER" />
      <item value="This has the same efficiency as the previous anti-pattern, but does not suffer from the drawback of being brittle." />
      <item value="Reads a provider without listening to it. AVOID calling [read] inside build if the value is used only for events: ```dart Widget build(BuildContext context) { counter is used only for the onPressed of RaisedButton final counter = ref.read(counterProvider); return RaisedButton( onPressed: () =&gt; counter.increment(), ); } ``` While this code is not bugged in itself, this is an anti-pattern. It could easily lead to bugs in the future after refactoring the widget to use `counter` for other things, but forget to change [read] into [Consumer]`ref.watch(`. CONSIDER calling [read] inside event handlers: ```dart Widget build(BuildContext context) { return RaisedButton( onPressed: () { as performant as the previous solution, but resilient to refactoring ref.read(counterProvider).increment(), }, ); } ```" />
      <item value="as performant as the previous solution, but resilient to refactoring" />
      <item value="Returns a modifiable list of interceptors that observe the full span of each call: from before the connection is established (if any) until after the response source is selected (either the origin server, cache, or both)." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="9" />
        <entry key="ENGLISH" value="10" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1655436721463" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
  </component>
</application>