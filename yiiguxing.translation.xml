<application>
  <component name="AppStorage">
    <histories>
      <item value="Whether the `newWidget` can be used to update an [Element] that currently has the `oldWidget` as its configuration. An element that uses a given widget as its configuration can be updated to use another widget as its configuration if, and only if, the two widgets have [runtimeType] and [key] properties that are [operator==]. If the widgets have no key (their key is null), then they are considered a match if they have the same type, even if their children are completely different." />
      <item value="Closing a &lt;tt&gt;ByteArrayOutputStream&lt;tt&gt; has no effect. The methods in this class can be called after the stream has been closed without generating an &lt;tt&gt;IOException&lt;tt&gt;." />
      <item value="Returns an input stream that reads from this open connection. A SocketTimeoutException can be thrown when reading from the returned input stream if the read timeout expires before data is available for read. @return an input stream that reads from this open connection. @exception IOException if an IO error occurs while creating the input stream. @exception UnknownServiceException if the protocol does not support input. @see setReadTimeout(int) @see getReadTimeout()" />
      <item value="Closes this output stream and releases any system resources associated with this stream. The general contract of &lt;code&gt;close&lt;code&gt; is that it closes the output stream. A closed stream cannot perform output operations and cannot be reopened. &lt;p&gt; The &lt;code&gt;close&lt;code&gt; method of &lt;code&gt;OutputStream&lt;code&gt; does nothing. @exception IOException if an IO error occurs." />
      <item value="Flushes this output stream and forces any buffered output bytes to be written out. The general contract of &lt;code&gt;flush&lt;code&gt; is that calling it is an indication that, if any bytes previously written have been buffered by the implementation of the output stream, such bytes should immediately be written to their intended destination. &lt;p&gt; If the intended destination of this stream is an abstraction provided by the underlying operating system, for example a file, then flushing the stream guarantees only that bytes previously written to the stream are passed to the operating system for writing; it does not guarantee that they are actually written to a physical device such as a disk drive. &lt;p&gt; The &lt;code&gt;flush&lt;code&gt; method of &lt;code&gt;OutputStream&lt;code&gt; does nothing. @exception IOException if an IO error occurs." />
      <item value="Response" />
      <item value="Create a proxy for the wrapped object allowing to typesafely invoke methods on it using a custom interface. @param proxyType The interface type that is implemented by the proxy. @return a proxy for the wrapped object" />
      <item value="路由 fluro: ^1.7.8 请求缓存 dio_http_cache: ^0.2.7 图片缓存 cached_network_image: ^2.1.0+1 轮播图 - 插件暂未升级2.0 flutter_swiper: ^1.1.6 加载html标签 flutter_html: ^0.11.1 消息提示框 flutter_svprogresshud: ^0.0.6 fluttertoast: ^7.1.5 响应式编程 rxdart: ^0.23.0 消息中心（事件发送和监听） event_bus: ^1.1.1 调用底层的拨打电话、发送邮件、发送信息以及打开网址和打开第三方应用等等 url_launcher: ^5.4.11 图片选择 image_picker: ^0.6.7+4 音频播放 audioplayers: ^0.15.1 日期选择 flutter_rounded_date_picker: ^1.0.5 格式化时间 date_format: ^1.0.8 获取手机上的文件，清除缓存使用的 path_provider: ^1.6.11 前往app设置 app_settings: ^4.0.2 地区选择 - 插件暂未升级2.0 city_pickers: ^0.1.30 工具类库 flustars: ^0.3.2 权限申请 permission_handler: ^4.2.0 安卓安卓插件 - 插件暂未升级2.0 install_plugin: ^2.0.1 侧滑组件 flutter_slidable: ^0.5.7 画图表 fl_chart: ^0.12.1 charts_flutter: ^0.10.0 syncfusion_flutter_charts: ^18.4.47 扫描二维码 flutter_qr_reader: ^1.0.3 图片压缩 flutter_native_image: ^0.0.5 图片视图，放大缩小等 photo_view: ^0.10.3 保存图片到相册 image_gallery_saver: ^1.6.8 二维码生成 qr_flutter: ^3.1.0" />
      <item value="Denotes that any overriding methods should invoke this method as well." />
      <item value="recharge" />
      <item value="To remove routes until a route with a certain name, use the [RoutePredicate] returned from [ModalRoute.withName]. To remove all the routes below the pushed route, use a [RoutePredicate] that always returns false (e.g. `(Route&lt;dynamic&gt; route) =&gt; false`)." />
      <item value="Push the route with the given name onto the navigator that most tightly encloses the given context, and then remove all the previous routes until the `predicate` returns true." />
      <item value="A piece of material." />
      <item value="the extentAfter distance of trigger loading" />
      <item value="The boundary is located at the bottom edge and stops when inertia rolls under the boundary distance" />
      <item value="A constant that is true if the application was compiled to run on the web. This implementation takes advantage of the fact that JavaScript does not support integers. In this environment, Dart's doubles and ints are backed by the same kind of object. Thus a double `0.0` is identical to an integer `0`. This is not true for Dart code running in AOT or on the VM." />
      <item value="Pop the current route off the navigator that most tightly encloses the given context and push a named route in its place." />
      <item value="Switches themes for this {@code Activity} from the theme used to launch this {@code Activity} to a &quot;normal theme&quot; that is intended for regular {@code Activity} operation. &lt;p&gt;This behavior is offered so that a &quot;launch screen&quot; can be displayed while the application initially loads. To utilize this behavior in an app, do the following: &lt;ol&gt; &lt;li&gt;Create 2 different themes in style.xml: one theme for the launch screen and one theme for normal display. &lt;li&gt;In the launch screen theme, set the &quot;windowBackground&quot; property to a {@code Drawable} of your choice. &lt;li&gt;In the normal theme, customize however you'd like. &lt;li&gt;In the AndroidManifest.xml, set the theme of your {@code FlutterActivity} to your launch theme. &lt;li&gt;Add a {@code &lt;meta-data&gt;} property to your {@code FlutterActivity} with a name of &quot;io.flutter.embedding.android.NormalTheme&quot; and set the resource to your normal theme, e.g., {@code android:resource=&quot;@styleMyNormalTheme}. &lt;ol&gt; With the above settings, your launch theme will be used when loading the app, and then the theme will be switched to your normal theme once the app has initialized. &lt;p&gt;Do not change aspects of system chrome between a launch theme and normal theme. Either define both themes to be fullscreen or not, and define both themes to display the same status bar and navigation bar settings. If you wish to adjust system chrome once your Flutter app renders, use platform channels to instruct Android to do so at the appropriate time. This will avoid any jarring visual changes during app startup." />
      <item value="Sets this {@code Activity}'s {@code Window} background to be transparent, and hides the status bar, if this {@code Activity}'s desired {@link BackgroundMode} is {@link BackgroundModetransparent}. &lt;p&gt;For {@code Activity} transparency to work as expected, the theme applied to this {@code Activity} must include {@code &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;item&gt;}." />
      <item value="Theme applied to the Android Window as soon as the process has started. This theme determines the color of the Android Window while your Flutter UI initializes, as well as behind your Flutter UI while its running." />
      <item value="{@macro flutter.widgets.widgetsApp.shortcuts} {@tool snippet} This example shows how to add a single shortcut for [LogicalKeyboardKey.select] to the default shortcuts without needing to add your own [Shortcuts] widget. Alternatively, you could insert a [Shortcuts] widget with just the mapping you want to add between the [WidgetsApp] and its child and get the same effect." />
      <item value="Why are we surrounding a builder with a builder? The widget.builder may contain code that invokes Theme.of(), which should return the theme we selected above in AnimatedTheme. However, if we invoke widget.builder() directly as the child of AnimatedTheme then there is no Context separating them, and the widget.builder() will not find the theme. Therefore, we surround widget.builder with yet another builder so that a context separates them and Theme.of() correctly resolves to the theme we passed to AnimatedTheme." />
      <item value="{@macro flutter.widgets.widgetsApp.builder} Material specific features such as [showDialog] and [showMenu], and widgets such as [Tooltip], [PopupMenuButton], also require a [Navigator] to properly function." />
      <item value="Manually wait for window size to be initialized `Recommended` to use before you need access window size or in custom splashbootstrap screen [FutureBuilder] example: ```dart ... ScreenUtil.init(context, ...); ... FutureBuilder( future: Future.wait([..., ensureScreenSize(), ...]), builder: (context, snapshot) { if (snapshot.hasData) return const HomeScreen(); return Material( child: LayoutBuilder( ... ), ); }, ) ```" />
      <item value="The number of device pixels for each logical pixel. This number might not be a power of two. Indeed, it might not even be an integer. For example, the Nexus 6 has a device pixel ratio of 3.5." />
      <item value="The size of the media in logical pixels (e.g, the size of the screen)." />
      <item value="If a [Navigator] is created, at least one of these options must handle the `` route, since it is used when an invalid [initialRoute] is specified on startup (e.g. by another application launching this one with an intent on Android; see [dart:ui.PlatformDispatcher.defaultRouteName])." />
      <item value="All restorable properties must be registered with the mixin. After registration, the counter either has its old value restored or is initialized to its default value." />
      <item value="In this example, the restoration ID for the mixin is passed in through the [StatefulWidget]'s constructor." />
      <item value="A property that has been registered outside of [restoreState] must be re-registered within [restoreState] the next time that method is called unless it has been unregistered with [unregisterFromRestoration]." />
      <item value="The current value of the counter is stored in a [RestorableProperty]. During state restoration it is automatically restored to its old value. If no restoration data is available to restore the counter from, it is initialized to the specified default value of zero." />
      <item value="The [State] object uses the [RestorationMixin] to make the current value of the counter restorable." />
      <item value="Denotes that the request body will use form URL encoding. Fields should be declared as parameters and annotated with {@link Field @Field}. &lt;p&gt; Requests made with this annotation will have {@code applicationx-www-form-urlencoded} MIME type. Field names and values will be UTF-8 encoded before being URI-encoded in accordance to &lt;a href=&quot;http:tools.ietf.orghtmlrfc3986&quot;&gt;RFC-3986&lt;a&gt;." />
      <item value="Encodes the string [component] according to the HTML 4.01 rules for encoding the posting of a HTML form as a query string component. Encode the string [component] according to the HTML 4.01 rules for encoding the posting of a HTML form as a query string component. The component is first encoded to bytes using [encoding]. The default is to use [utf8] encoding, which preserves all the characters that don't need encoding. Then the resulting bytes are &quot;percent-encoded&quot;. This transforms spaces (U+0020) to a plus sign ('+') and all bytes that are not the ASCII decimal digits, letters or one of '-._~' are written as a percent sign '%' followed by the two-digit hexadecimal representation of the byte. Note that the set of characters which are percent-encoded is a superset of what HTML 4.01 requires, since it refers to RFC 1738 for reserved characters. When manually encoding query components remember to encode each part separately before building the query string." />
      <item value="{@template riverpod.stateprovider.notifier} Obtains the [StateController] associated with this provider, but without listening to it. Listening to this provider may cause providerswidgets to rebuild in the event that the [StateController] it recreated. It is preferable to do: ```dart ref.watch(stateProvider.notifier) ``` instead of: ```dart ref.read(stateProvider) ``` The reasoning is, using `read` could cause hard to catch bugs, such as not rebuilding dependent providerswidgets after using `ref.refresh` on this provider. {@endtemplate}" />
      <item value="anti-pattern" />
      <item value="CONSIDER" />
      <item value="This has the same efficiency as the previous anti-pattern, but does not suffer from the drawback of being brittle." />
      <item value="Reads a provider without listening to it. AVOID calling [read] inside build if the value is used only for events: ```dart Widget build(BuildContext context) { counter is used only for the onPressed of RaisedButton final counter = ref.read(counterProvider); return RaisedButton( onPressed: () =&gt; counter.increment(), ); } ``` While this code is not bugged in itself, this is an anti-pattern. It could easily lead to bugs in the future after refactoring the widget to use `counter` for other things, but forget to change [read] into [Consumer]`ref.watch(`. CONSIDER calling [read] inside event handlers: ```dart Widget build(BuildContext context) { return RaisedButton( onPressed: () { as performant as the previous solution, but resilient to refactoring ref.read(counterProvider).increment(), }, ); } ```" />
      <item value="as performant as the previous solution, but resilient to refactoring" />
      <item value="Returns a modifiable list of interceptors that observe the full span of each call: from before the connection is established (if any) until after the response source is selected (either the origin server, cache, or both)." />
      <item value="Returns a modifiable list of interceptors that observe a single network request and response. These interceptors must call {@link Interceptor.Chainproceed} exactly once: it is an error for a network interceptor to short-circuit or repeat a network request." />
      <item value="Converts [value] to a JSON string. If value contains objects that are not directly encodable to a JSON string (a value that is not a number, boolean, string, null, list or a map with string keys), the [toEncodable] function is used to convert it to an object that must be directly encodable. If [toEncodable] is omitted, it defaults to a function that returns the result of calling `.toJson()` on the unencodable object." />
      <item value="Combines the string representation of elements into a single string. Each element is converted to a string using its [Object.toString] method. If [separator] is provided, it is inserted between element string representations. The returned future is completed with the combined string when this stream is done. If this stream emits an error, or the call to [Object.toString] throws, the returned future is completed with that error, and processing stops." />
      <item value="Describes the part of the user interface represented by this widget. The framework calls this method when this widget is inserted into the tree in a given [BuildContext] and when the dependencies of this widget change (e.g., an [InheritedWidget] referenced by this widget changes). This method can potentially be called in every frame and should not have any side effects beyond building a widget. The framework replaces the subtree below this widget with the widget returned by this method, either by updating the existing subtree or by removing the subtree and inflating a new subtree, depending on whether the widget returned by this method can update the root of the existing subtree, as determined by calling [Widget.canUpdate]. Typically implementations return a newly created constellation of widgets that are configured with information from this widget's constructor and from the given [BuildContext]. The given [BuildContext] contains information about the location in the tree at which this widget is being built. For example, the context provides the set of inherited widgets for this location in the tree. A given widget might be built with multiple different [BuildContext] arguments over time if the widget is moved around the tree or if the widget is inserted into the tree in multiple places at once. The implementation of this method must only depend on: the fields of the widget, which themselves must not change over time, and any ambient state obtained from the `context` using [BuildContext.dependOnInheritedWidgetOfExactType]." />
      <item value="The framework replaces the subtree below this widget with the widget returned by this method, either by updating the existing subtree or by removing the subtree and inflating a new subtree, depending on whether the widget returned by this method can update the root of the existing subtree, as determined by calling [Widget.canUpdate]." />
      <item value="Creates a scrollable, linear array of widgets that are created on demand. This constructor is appropriate for list views with a large (or infinite) number of children because the builder is called only for those children that are actually visible. Providing a non-null `itemCount` improves the ability of the [ListView] to estimate the maximum scroll extent. The `itemBuilder` callback will be called only with indices greater than or equal to zero and less than `itemCount`. The `itemBuilder` should always return a non-null widget, and actually create the widget instances when called. Avoid using a builder that returns a previously-constructed widget; if the list view's children are created in advance, or all at once when the [ListView] itself is created, it is more efficient to use the [ListView] constructor. Even more efficient, however, is to create the instances on demand using this constructor's `itemBuilder` callback. The `addAutomaticKeepAlives` argument corresponds to the [SliverChildBuilderDelegate.addAutomaticKeepAlives] property. The `addRepaintBoundaries` argument corresponds to the [SliverChildBuilderDelegate.addRepaintBoundaries] property. The `addSemanticIndexes` argument corresponds to the [SliverChildBuilderDelegate.addSemanticIndexes] property. None may be null." />
      <item value="A widget that aligns its child within itself and optionally sizes itself based on the child's size. For example, to align a box at the bottom right, you would pass this box a tight constraint that is bigger than the child's natural size, with an alignment of [Alignment.bottomRight]. {@youtube 560 315 https:www.youtube.comwatch?v=g2E7yl3MwMk} This widget will be as big as possible if its dimensions are constrained and [widthFactor] and [heightFactor] are null. If a dimension is unconstrained and the corresponding size factor is null then the widget will match its child's size in that dimension. If a size factor is non-null then the corresponding dimension of this widget will be the product of the child's dimension and the size factor. For example if widthFactor is 2.0 then the width of this widget will always be twice its child's width. How it works The [alignment] property describes a point in the `child`'s coordinate system and a different point in the coordinate system of this widget. The [Align] widget positions the `child` such that both points are lined up on top of each other." />
      <item value="A widget that clips its child using a rectangle. By default, [ClipRect] prevents its child from painting outside its bounds, but the size and location of the clip rect can be customized using a custom [clipper]. [ClipRect] is commonly used with these widgets, which commonly paint outside their bounds:" />
      <item value="If non-null, sets its width to the child's width multiplied by this factor. Can be both greater and less than 1.0 but must be non-negative." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="9" />
        <entry key="ENGLISH" value="10" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1654507854653" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
  </component>
</application>