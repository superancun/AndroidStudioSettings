<application>
  <component name="AppStorage">
    <histories>
      <item value="Returns a modifiable list of interceptors that observe the full span of each call: from before the connection is established (if any) until after the response source is selected (either the origin server, cache, or both)." />
      <item value="Returns a modifiable list of interceptors that observe a single network request and response. These interceptors must call {@link Interceptor.Chainproceed} exactly once: it is an error for a network interceptor to short-circuit or repeat a network request." />
      <item value="Converts [value] to a JSON string. If value contains objects that are not directly encodable to a JSON string (a value that is not a number, boolean, string, null, list or a map with string keys), the [toEncodable] function is used to convert it to an object that must be directly encodable. If [toEncodable] is omitted, it defaults to a function that returns the result of calling `.toJson()` on the unencodable object." />
      <item value="Combines the string representation of elements into a single string. Each element is converted to a string using its [Object.toString] method. If [separator] is provided, it is inserted between element string representations. The returned future is completed with the combined string when this stream is done. If this stream emits an error, or the call to [Object.toString] throws, the returned future is completed with that error, and processing stops." />
      <item value="Describes the part of the user interface represented by this widget. The framework calls this method when this widget is inserted into the tree in a given [BuildContext] and when the dependencies of this widget change (e.g., an [InheritedWidget] referenced by this widget changes). This method can potentially be called in every frame and should not have any side effects beyond building a widget. The framework replaces the subtree below this widget with the widget returned by this method, either by updating the existing subtree or by removing the subtree and inflating a new subtree, depending on whether the widget returned by this method can update the root of the existing subtree, as determined by calling [Widget.canUpdate]. Typically implementations return a newly created constellation of widgets that are configured with information from this widget's constructor and from the given [BuildContext]. The given [BuildContext] contains information about the location in the tree at which this widget is being built. For example, the context provides the set of inherited widgets for this location in the tree. A given widget might be built with multiple different [BuildContext] arguments over time if the widget is moved around the tree or if the widget is inserted into the tree in multiple places at once. The implementation of this method must only depend on: the fields of the widget, which themselves must not change over time, and any ambient state obtained from the `context` using [BuildContext.dependOnInheritedWidgetOfExactType]." />
      <item value="The framework replaces the subtree below this widget with the widget returned by this method, either by updating the existing subtree or by removing the subtree and inflating a new subtree, depending on whether the widget returned by this method can update the root of the existing subtree, as determined by calling [Widget.canUpdate]." />
      <item value="Creates a scrollable, linear array of widgets that are created on demand. This constructor is appropriate for list views with a large (or infinite) number of children because the builder is called only for those children that are actually visible. Providing a non-null `itemCount` improves the ability of the [ListView] to estimate the maximum scroll extent. The `itemBuilder` callback will be called only with indices greater than or equal to zero and less than `itemCount`. The `itemBuilder` should always return a non-null widget, and actually create the widget instances when called. Avoid using a builder that returns a previously-constructed widget; if the list view's children are created in advance, or all at once when the [ListView] itself is created, it is more efficient to use the [ListView] constructor. Even more efficient, however, is to create the instances on demand using this constructor's `itemBuilder` callback. The `addAutomaticKeepAlives` argument corresponds to the [SliverChildBuilderDelegate.addAutomaticKeepAlives] property. The `addRepaintBoundaries` argument corresponds to the [SliverChildBuilderDelegate.addRepaintBoundaries] property. The `addSemanticIndexes` argument corresponds to the [SliverChildBuilderDelegate.addSemanticIndexes] property. None may be null." />
      <item value="A widget that aligns its child within itself and optionally sizes itself based on the child's size. For example, to align a box at the bottom right, you would pass this box a tight constraint that is bigger than the child's natural size, with an alignment of [Alignment.bottomRight]. {@youtube 560 315 https:www.youtube.comwatch?v=g2E7yl3MwMk} This widget will be as big as possible if its dimensions are constrained and [widthFactor] and [heightFactor] are null. If a dimension is unconstrained and the corresponding size factor is null then the widget will match its child's size in that dimension. If a size factor is non-null then the corresponding dimension of this widget will be the product of the child's dimension and the size factor. For example if widthFactor is 2.0 then the width of this widget will always be twice its child's width. How it works The [alignment] property describes a point in the `child`'s coordinate system and a different point in the coordinate system of this widget. The [Align] widget positions the `child` such that both points are lined up on top of each other." />
      <item value="A widget that clips its child using a rectangle. By default, [ClipRect] prevents its child from painting outside its bounds, but the size and location of the clip rect can be customized using a custom [clipper]. [ClipRect] is commonly used with these widgets, which commonly paint outside their bounds:" />
      <item value="If non-null, sets its width to the child's width multiplied by this factor. Can be both greater and less than 1.0 but must be non-negative." />
      <item value="This is the same as `contain` if that would shrink the image, otherwise it is the same as `none`." />
      <item value="If non-null, require the image to have this width. If null, the image will pick a size that best preserves its intrinsic aspect ratio. It is strongly recommended that either both the [width] and the [height] be specified, or that the widget be placed in a context that sets tight layout constraints, so that the image does not change size as it loads. Consider using [fit] to adapt the image's rendering to fit the given width and height if the exact image dimensions are not known in advance." />
      <item value="Called whenever the widget configuration changes. If the parent widget rebuilds and request that this location in the tree update to display a new widget with the same [runtimeType] and [Widget.key], the framework will update the [widget] property of this [State] object to refer to the new widget and then call this method with the previous widget as an argument. Override this method to respond when the [widget] changes (e.g., to start implicit animations). The framework always calls [build] after calling [didUpdateWidget], which means any calls to [setState] in [didUpdateWidget] are redundant. {@macro flutter.widgets.State.initState} Implementations of this method should start with a call to the inherited method, as in `super.didUpdateWidget(oldWidget)`." />
      <item value="Called to obtain the child widget. This function is called whenever this widget is included in its parent's build and the old widget (if any) that it synchronizes with has a distinct object identity. Typically the parent's build method will construct a new tree of widgets and so a new Builder child will not be [identical] to the corresponding old one." />
      <item value="A widget that lays the child out as if it was in the tree, but without painting anything, without making the child available for hit testing, and without taking any room in the parent." />
      <item value="Register callbacks to be called when this future completes. When this future completes with a value, the [onValue] callback will be called with that value. If this future is already completed, the callback will not be called immediately, but will be scheduled in a later microtask. If [onError] is provided, and this future completes with an error, the `onError` callback is called with that error and its stack trace. The `onError` callback must accept either one argument or two arguments where the latter is a [StackTrace]. If `onError` accepts two arguments, it is called with both the error and the stack trace, otherwise it is called with just the error object. The `onError` callback must return a value or future that can be used to complete the returned future, so it must be something assignable to `FutureOr&lt;R&gt;`. Returns a new [Future] which is completed with the result of the call to `onValue` (if this future completes with a value) or to `onError` (if this future completes with an error). If the invoked callback throws, the returned future is completed with the thrown error and a stack trace for the error. In the case of `onError`, if the exception thrown is `identical` to the error argument to `onError`, the throw is considered a rethrow, and the original stack trace is used instead. If the callback returns a [Future], the future returned by `then` will be completed with the same result as the future returned by the callback. If [onError] is not given, and this future completes with an error, the error is forwarded directly to the returned future. In most cases, it is more readable to use [catchError] separately, possibly with a `test` parameter, instead of handling both value and error in a single [then] call. Note that futures don't delay reporting of errors until listeners are added. If the first `then` or `catchError` call happens after this future has completed with an error, then the error is reported as unhandled error. See the description on [Future]." />
      <item value="tight" />
      <item value="Column has various properties to control how it sizes itself and how it positions its children. Here we use mainAxisAlignment to center the children vertically; the main axis here is the vertical axis because Columns are vertical (the cross axis would be horizontal)." />
      <item value="Invoke &quot;debug painting&quot; (press &quot;p&quot; in the console, choose the &quot;Toggle Debug Paint&quot; action from the Flutter Inspector in Android Studio, or the &quot;Toggle Debug Paint&quot; command in Visual Studio Code) to see the wireframe for each widget." />
      <item value="Column is also a layout widget. It takes a list of children and arranges them vertically. By default, it sizes itself to fit its children horizontally, and tries to be as tall as its parent." />
      <item value="Center is a layout widget. It takes a single child and positions it in the middle of the parent." />
      <item value="Here we take the value from the MyHomePage object that was created by the App.build method, and use it to set our appbar title." />
      <item value="This method is rerun every time setState is called, for instance as done by the _incrementCounter method above. The Flutter framework has been optimized to make rerunning build methods fast, so that you can just rebuild anything that needs updating rather than having to individually change instances of widgets." />
      <item value="This call to setState tells the Flutter framework that something has changed in this State, which causes it to rerun the build method below so that the display can reflect the updated values. If we changed _counter without calling setState(), then the build method would not be called again, and so nothing would appear to happen." />
      <item value="This widget is the home page of your application. It is stateful, meaning that it has a State object (defined below) that contains fields that affect how it looks. This class is the configuration for the state. It holds the values (in this case the title) provided by the parent (in this case the App widget) and used by the build method of the State. Fields in a Widget subclass are always marked &quot;final&quot;." />
      <item value="This is the theme of your application. Try running your application with &quot;flutter run&quot;. You'll see the application has a blue toolbar. Then, without quitting the app, try changing the primarySwatch below to Colors.green and then invoke &quot;hot reload&quot; (press &quot;r&quot; in the console where you ran &quot;flutter run&quot;, or simply save your changes to &quot;hot reload&quot; in a Flutter IDE). Notice that the counter didn't reset back to zero; the application is not restarted." />
      <item value="Flag for {@link setSystemUiVisibility(int)}: View would like its window to be laid out as if it has requested {@link SYSTEM_UI_FLAG_HIDE_NAVIGATION}, even if it currently hasn't. This allows it to avoid artifacts when switching in and out of that mode, at the expense that some of its user interface may be covered by screen decorations when they are shown. You can perform layout of your inner UI elements to account for the navigation system UI through the {@link fitSystemWindows(Rect)} method. @deprecated For floating windows, use {@link LayoutParamssetFitInsetsTypes(int)} with {@link TypenavigationBars()}. For non-floating windows that fill the screen, call {@link WindowsetDecorFitsSystemWindows(boolean)} with {@code false}." />
      <item value="Create an Observable by wrapping an ObservableSource &lt;em&gt;which has to be implemented according to the Reactive Streams based Observable specification by handling disposal correctly; no safeguards are provided by the Observable itself&lt;em&gt;. &lt;dl&gt; &lt;dt&gt;&lt;b&gt;Scheduler:&lt;b&gt;&lt;dt&gt; &lt;dd&gt;{@code unsafeCreate} by default doesn't operate on any particular {@link Scheduler}.&lt;dd&gt; &lt;dl&gt; @param &lt;T&gt; the value type emitted @param onSubscribe the ObservableSource instance to wrap @return the new Observable instance" />
      <item value="Returns a string having trailing characters from the [chars] array removed." />
      <item value="Removes the first occurrence of the specified element from this list, if it is present. If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index {@code i} such that &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;tt&gt; (if such an element exists). Returns {@code true} if this list contained the specified element (or equivalently, if this list changed as a result of the call). @param o element to be removed from this list, if present @return {@code true} if this list contained the specified element" />
      <item value="Return the FragmentManager for interacting with fragments associated with this fragment's activity. Note that this will be non-null slightly before {@link getActivity()}, during the time from when the fragment is placed in a {@link FragmentTransaction} until it is committed and attached to its activity. &lt;p&gt;If this Fragment is a child of another Fragment, the FragmentManager returned here will be the parent's {@link getChildFragmentManager()}. @see getParentFragmentManager() @deprecated This has been removed in favor of &lt;code&gt;getParentFragmentManager()&lt;code&gt; which throws an {@link IllegalStateException} if the FragmentManager is null. Check if {@link isAdded()} returns &lt;code&gt;false&lt;code&gt; to determine if the FragmentManager is &lt;code&gt;null&lt;code&gt;." />
      <item value="Returns the thread group to which this thread belongs. This method returns null if this thread has died (been stopped)." />
      <item value="Create an implementation of the API endpoints defined by the {@code service} interface. &lt;p&gt;The relative path for a given method is obtained from an annotation on the method describing the request type. The built-in methods are {@link retrofit2.http.GET GET}, {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first parameter with {@link Url @Url}. &lt;p&gt;Method parameters can be used to replace parts of the URL by annotating them with {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier surrounded by curly braces (e.g., &quot;{foo}&quot;). To add items to the query string of a URL use {@link retrofit2.http.Query @Query}. &lt;p&gt;The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The object will be converted to request representation by one of the {@link Converter.Factory} instances. A {@link RequestBody} can also be used for a raw representation. &lt;p&gt;Alternative request body formats are supported by method annotations and corresponding parameter annotations: &lt;ul&gt; &lt;li&gt;{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation. &lt;li&gt;{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multipart data with parts specified by the {@link retrofit2.http.Part @Part} parameter annotation. &lt;ul&gt; &lt;p&gt;Additional static headers can be added for an endpoint using the {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a header annotate a parameter with {@link Header @Header}. &lt;p&gt;By default, methods return a {@link Call} which represents the HTTP request. The generic parameter of the call is the response body type and will be converted by one of the {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw representation. {@link Void} can be used if you do not care about the body contents." />
      <item value="Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence. The replacement proceeds from the beginning of the string to the end, for example, replacing &quot;aa&quot; with &quot;b&quot; in the string &quot;aaa&quot; will result in &quot;ba&quot; rather than &quot;ab&quot;." />
      <item value="Set the alpha component of {@code color} to be {@code alpha}." />
      <item value="Return true if the fragment is in the resumed state. This is true for the duration of {@link onResume()} and {@link onPause()} as well." />
      <item value="Broadcast Action: The current time has changed. Sent every minute. You &lt;em&gt;cannot&lt;em&gt; receive this through components declared in manifests, only by explicitly registering for it with {@link ContextregisterReceiver(BroadcastReceiver, IntentFilter) Context.registerReceiver()}. &lt;p class=&quot;note&quot;&gt;This is a protected intent that can only be sent by the system." />
      <item value="Returns the {@link ColorStateList} from the given resource. The resource can include themeable attributes, regardless of API level. @param context context to inflate against @param resId the resource identifier of the ColorStateList to retrieve" />
      <item value="KEY REMAIN COUNT" />
      <item value="KEY Remain count" />
      <item value="@return true if this view could ask the Handler to remove the Runnable, false otherwise. When the returned value is true, the Runnable may or may not have been actually removed from the message queue (for instance, if the Runnable was not in the queue already.)" />
      <item value="@return {@link getBindingAdapterPosition()} @deprecated This method is confusing when adapters nest other adapters. If you are calling this in the context of an Adapter, you probably want to call {@link getBindingAdapterPosition()} or if you want the position as {@link RecyclerView} sees it, you should call {@link getAbsoluteAdapterPosition()}." />
      <item value="This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0." />
      <item value="This class represents a Network Interface made up of a name, and a list of IP addresses assigned to this interface. It is used to identify the local interface on which a multicast group is joined. Interfaces are normally known by names such as &quot;le0&quot;." />
      <item value="Android-note: NetworkInterface has been rewritten to avoid native code. Fix upstream bug not returning link-down interfaces. http:b26238832" />
      <item value="If the package id is 0x00 or 0x01, it's either an undefined package or a framework id" />
      <item value="Sets a tag associated with this view and a key. A tag can be used to mark a view in its hierarchy and does not have to be unique within the hierarchy. Tags can also be used to store data within a view without resorting to another data structure. The specified key should be an id declared in the resources of the application to ensure it is unique (see the &lt;a href=&quot;{@docRoot}guidetopicsresourcesmore-resources.htmlId&quot;&gt;ID resource type&lt;a&gt;). Keys identified as belonging to the Android framework or not associated with any package will cause an {@link IllegalArgumentException} to be thrown." />
      <item value="Compat version of {@link java.util.function.Consumer} @param &lt;T&gt; the type of the input to the operation" />
      <item value="Window flag: hide all screen decorations (such as the status bar) while this window is displayed. This allows the window to use the entire display space for itself -- the status bar will be hidden when an app window with this flag set is on the top layer. A fullscreen window will ignore a value of {@link SOFT_INPUT_ADJUST_RESIZE} for the window's {@link softInputMode} field; the window will stay fullscreen and will not resize. &lt;p&gt;This flag can be controlled in your theme through the {@link android.R.attrwindowFullscreen} attribute; this attribute is automatically set for you in the standard fullscreen themes such as {@link android.R.styleTheme_NoTitleBar_Fullscreen}, {@link android.R.styleTheme_Black_NoTitleBar_Fullscreen}, {@link android.R.styleTheme_Light_NoTitleBar_Fullscreen}, {@link android.R.styleTheme_Holo_NoActionBar_Fullscreen}, {@link android.R.styleTheme_Holo_Light_NoActionBar_Fullscreen}, {@link android.R.styleTheme_DeviceDefault_NoActionBar_Fullscreen}, and {@link android.R.styleTheme_DeviceDefault_Light_NoActionBar_Fullscreen}.&lt;p&gt;" />
      <item value="Window flag: allow window to extend outside of the screen." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="9" />
        <entry key="ENGLISH" value="10" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1652756683716" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
  </component>
</application>